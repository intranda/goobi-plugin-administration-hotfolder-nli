package de.intranda.goobi.plugins.hotfolder.nli.model;

import java.io.File;
import java.io.IOException;
import java.nio.file.Path;
import java.time.Duration;
import java.time.Instant;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.apache.commons.lang.StringUtils;

import de.sub.goobi.helper.StorageProvider;
import de.sub.goobi.helper.StorageProviderInterface;
import lombok.Getter;
import lombok.extern.log4j.Log4j2;

@Log4j2
public class HotfolderFolder {
    private static StorageProviderInterface storageProvider = StorageProvider.getInstance();

    @Getter
    private Path projectFolder;

    @Getter
    private String templateName;
    // time of minutes that a folder should remain unmodified before the import of it starts
    private Integer minutesInactivity = 30;
    // list of paths of all files including folders inside the project folder
    private List<Path> projectFoldersFileList;
    // list of paths of all folders whose contents are to be imported
    private List<Path> lstProcessFolders;
    // name of the Thumbs.db file generated by some Windows Systems
    private static final String THUMBS_DB_FILE = "Thumbs.db";

    /**
     * constructor
     * 
     * @param projectFolder
     * @param templateName
     */
    public HotfolderFolder(Path projectFolder, String templateName) {
        this.projectFolder = projectFolder;
        this.templateName = templateName;
        this.projectFoldersFileList = storageProvider.listFiles(this.projectFolder.toString());

        getImportFolders();
    }

    /**
     * initialize the field lstProcessFolders and remove all Thumbs.db files from all process folders
     */
    private void getImportFolders() {
        lstProcessFolders = new ArrayList<>();
        
        for (Path barcodePath : projectFoldersFileList) {
            if (storageProvider.isDirectory(barcodePath)) {
                // remove the Thumbs.db file
                removeThumbsDbFile(barcodePath);
                // add the folder to the list
                lstProcessFolders.add(barcodePath);
            }
        }
    }

    /**
     * remove the Thumbs.db file generated by Windows System from the input folder path
     * 
     * @param folderPath path of the folder from which the Thumbs.db file should be removed
     */
    private void removeThumbsDbFile(Path folderPath) {
        List<Path> files = storageProvider.listFiles(folderPath.toString());
        for (Path file : files) {
            String fileName = file.getFileName().toString();
            if (THUMBS_DB_FILE.equals(fileName)) {
                try {
                    storageProvider.deleteFile(file);
                    return;

                } catch (IOException e) {
                    log.error("failed to remove the Thumbs.db file from " + folderPath);
                }
            }
        }
    }

    /**
     * get a list of paths to the folders that are ready for the import
     * 
     * @return a list of folders' paths that is ready for the import
     * @throws IOException
     */
    public List<Path> getCurrentProcessFolders() throws IOException {
        List<Path> lstFoldersToImport = new ArrayList<>();

        for (Path barcodePath : lstProcessFolders) {
            log.trace("looking at {}", barcodePath);
            Instant lastModified = Instant.ofEpochMilli(storageProvider.getLastModifiedDate(barcodePath));
            Instant thirtyMinutesAgo = Instant.now().minus(Duration.ofMinutes(minutesInactivity));
            if (lastModified.isBefore(thirtyMinutesAgo)) {
                log.trace("Adding process folder {} to list", barcodePath);
                lstFoldersToImport.add(barcodePath);
            } else {
                log.trace("Not adding process folder {}. Last modified time {} is not before {}", barcodePath, lastModified, thirtyMinutesAgo);
            }
        }

        return lstFoldersToImport;
    }

    /**
     * get the .xlsx file that is used to control the import
     * 
     * @return a File object
     */
    public File getImportFile() {
        for (Path filePath : projectFoldersFileList) {
            String fileName = filePath.getFileName().toString();
            if (fileName.endsWith(".xlsx") && !fileName.startsWith("~")) {
                return filePath.toFile();
            }
        }

        // no such file found
        return null;
    }

    /**
     * get the map from folders' paths to the names of their owners
     * 
     * @return the map from folders' paths to their owners' names
     */
    public Map<Path, String> getFolderOwnerMap() {
        Map<Path, String> folderOwnerMap = new HashMap<>();
        for (Path folderPath : lstProcessFolders) {
            String ownerName = getOwnerName(folderPath);
            if (StringUtils.isNotBlank(ownerName)) {
                folderOwnerMap.put(folderPath, ownerName);
                deleteOwnerFile(folderPath);
            }
        }

        return folderOwnerMap;
    }

    /**
     * get the owner's name of the folder
     * 
     * @param folderPath path of the folder whose owner is to be found
     * @return name of the .owner file without the extension
     */
    private String getOwnerName(Path folderPath) {
        Path ownerFilePath = getOwnerFilePath(folderPath);
        if (ownerFilePath != null) {
            String fileName = ownerFilePath.getFileName().toString();
            return fileName.substring(0, fileName.lastIndexOf(".")).trim();
        }

        return "";
    }

    /**
     * retrieve the path of the .owner file in the given folder
     * 
     * @param folderPath path of the folder from which the .owner file should be located
     * @return absolute path of the .owner file
     */
    private Path getOwnerFilePath(Path folderPath) {
        for (Path filePath : storageProvider.listFiles(folderPath.toString())) {
            String fileName = filePath.getFileName().toString();
            if (fileName.endsWith(".owner")) {
                // there should be at most only one such file 
                return filePath;
            }
        }

        return null;
    }

    /**
     * delete the .owner file from the given folder path
     * 
     * @param folderPath path of the folder from which the .owner file should be removed
     */
    public void deleteOwnerFile(Path folderPath) {
        log.debug("deleting .owner file in " + folderPath);

        Path ownerFilePath = getOwnerFilePath(folderPath);
        if (ownerFilePath != null) {
            try {
                storageProvider.deleteFile(ownerFilePath);
            } catch (IOException e) {
                log.error("failed to delete the .owner file in " + folderPath);
            }
        }
    }

}
