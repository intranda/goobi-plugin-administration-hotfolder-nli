package de.intranda.goobi.plugins.hotfolder.nli.model.hotfolder;

import java.io.File;
import java.io.IOException;
import java.nio.file.Path;
import java.time.Duration;
import java.time.Instant;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.apache.commons.lang.StringUtils;

import de.sub.goobi.helper.StorageProviderInterface;
import lombok.Getter;
import lombok.extern.log4j.Log4j2;

@Log4j2
public class HotfolderFolder {

    private final StorageProviderInterface storageProvider;

    @Getter
    private Path projectFolder;

    @Getter
    private String templateName;
    // time of minutes that a folder should remain unmodified before the import of it starts
    private Integer minutesInactivity = 30;
    // list of paths of all files including folders inside the project folder
    private List<Path> projectFoldersFileList;
    // list of paths of all folders whose contents are to be imported
    private List<Path> lstProcessFolders;
    // name of the Thumbs.db file generated by some Windows Systems
    private static final String THUMBS_DB_FILE = "Thumbs.db";
    // extension of the owner file
    private static final String OWNER_FILE_EXTENSION = ".owner";

    /**
     * constructor
     * 
     * @param projectFolder
     * @param templateName
     */
    public HotfolderFolder(Path projectFolder, String templateName, StorageProviderInterface storageProvider) {
        this.projectFolder = projectFolder;
        this.templateName = templateName;
        this.projectFoldersFileList = storageProvider.listFiles(this.projectFolder.toString());
        this.storageProvider = storageProvider;

        getImportFolders();
    }

    /**
     * initialize the field lstProcessFolders and remove all Thumbs.db files from all process folders
     */
    private void getImportFolders() {
        lstProcessFolders = new ArrayList<>();

        for (Path barcodePath : projectFoldersFileList) {
            if (storageProvider.isDirectory(barcodePath)) {
                // remove the Thumbs.db file
                removeThumbsDbFile(barcodePath);
                // add the folder to the list
                lstProcessFolders.add(barcodePath);
            }
        }
    }

    /**
     * remove the Thumbs.db file generated by Windows System from the input folder path
     * 
     * @param folderPath path of the folder from which the Thumbs.db file should be removed
     */
    private void removeThumbsDbFile(Path folderPath) {
        List<Path> files = storageProvider.listFiles(folderPath.toString());
        for (Path file : files) {
            String fileName = file.getFileName().toString();
            if (THUMBS_DB_FILE.equals(fileName)) {
                try {
                    storageProvider.deleteFile(file);
                    return;

                } catch (IOException e) {
                    log.error("failed to remove the Thumbs.db file from " + folderPath);
                }
            }
        }
    }

    /**
     * get a list of paths to the folders that are ready for the import
     * 
     * @return a list of folders' paths that is ready for the import
     * @throws IOException
     */
    public List<Path> getCurrentProcessFolders() throws IOException {
        List<Path> lstFoldersToImport = new ArrayList<>();

        for (Path barcodePath : lstProcessFolders) {
            log.trace("looking at {}", barcodePath);
            Instant lastModified = Instant.ofEpochMilli(storageProvider.getLastModifiedDate(barcodePath));
            Instant thirtyMinutesAgo = Instant.now().minus(Duration.ofMinutes(minutesInactivity));
            if (lastModified.isBefore(thirtyMinutesAgo)) {
                log.trace("Adding process folder {} to list", barcodePath);
                lstFoldersToImport.add(barcodePath);
            } else {
                log.trace("Not adding process folder {}. Last modified time {} is not before {}", barcodePath, lastModified, thirtyMinutesAgo);
            }
        }

        return lstFoldersToImport;
    }

    /**
     * get the .xlsx file that is used to control the import
     * 
     * @return a File object
     */
    public File getImportFile() {
        for (Path filePath : projectFoldersFileList) {
            String fileName = filePath.getFileName().toString();
            if (fileName.endsWith(".xlsx") && !fileName.startsWith("~")) {
                return filePath.toFile();
            }
        }

        // no such file found
        return null;
    }

    /**
     * get the map from folders' paths to the names of their owners
     * 
     * @return the map from folders' paths to their owners' names
     */
    public Map<Path, String> getFolderOwnerMap() {
        Map<Path, String> folderOwnerMap = new HashMap<>();
        for (Path folderPath : lstProcessFolders) {
            String ownerName = getOwnerName(folderPath);
            if (StringUtils.isNotBlank(ownerName)) {
                folderOwnerMap.put(folderPath, ownerName);
            }
        }

        return folderOwnerMap;
    }

    /**
     * get the owner's name of the folder
     * 
     * @param folderPath path of the folder whose owner is to be found
     * @return name of the .owner file without the extension
     */
    private String getOwnerName(Path folderPath) {
        Path ownerFilePath = getOwnerFilePath(folderPath);
        if (ownerFilePath != null) {
            String fileName = ownerFilePath.getFileName().toString();
            return fileName.substring(0, fileName.lastIndexOf(".")).trim();
        }

        return "";
    }

    /**
     * retrieve the path of the .owner file in the given folder
     * 
     * @param folderPath path of the folder from which the .owner file should be located
     * @return absolute path of the .owner file
     */
    private Path getOwnerFilePath(Path folderPath) {
        for (Path filePath : storageProvider.listFiles(folderPath.toString())) {
            String fileName = filePath.getFileName().toString();
            if (fileName.endsWith(OWNER_FILE_EXTENSION)) {
                // there should be at most only one such file 
                return filePath;
            }
        }

        return null;
    }

    /**
     * delete the .owner file from the given folder path
     * 
     * @param folderPath path of the folder from which the .owner file should be removed
     */
    public void deleteOwnerFile(Path folderPath) {
        log.debug("deleting " + OWNER_FILE_EXTENSION + " file from " + folderPath);

        Path ownerFilePath = getOwnerFilePath(folderPath);
        if (ownerFilePath != null) {
            try {
                storageProvider.deleteFile(ownerFilePath);
            } catch (IOException e) {
                log.error("failed to delete the " + OWNER_FILE_EXTENSION + " file in " + folderPath);
            }
        }
    }

    /**
     * Delete the file with the extension '.owner' in the process path which name ends with the given 'processTitle'
     * 
     * @param processTitle
     * @return
     */
    public boolean deleteOwnerFile(String processTitle) {
        Map<Path, String> folderOwnerMap = getFolderOwnerMap();
        for (Map.Entry<Path, String> entry : folderOwnerMap.entrySet()) {
            Path folderPath = entry.getKey();
            String folderName = folderPath.getFileName().toString();
            if (processTitle.endsWith(folderName)) {
                deleteOwnerFile(folderPath);
                return true;
            }
        }
        return false;
    }

    /**
     * Get the base name of the file with the extension '.owner' in the process path which name ends with the given 'processTitle'
     * 
     * @param processTitle
     * @return
     */
    public String getOwnerName(String processTitle) {
        Map<Path, String> folderOwnerMap = getFolderOwnerMap();
        for (Map.Entry<Path, String> entry : folderOwnerMap.entrySet()) {
            Path folderPath = entry.getKey();
            String folderName = folderPath.getFileName().toString();
            if (processTitle.endsWith(folderName)) {
                String ownerName = entry.getValue();
                log.debug("ownerName = " + ownerName);
                return ownerName;
            }
        }

        // not found
        log.debug("ownerName not set");
        return "";
    }

    /**
     * get the extension of the owner file
     * 
     * @return the static constant OWNER_FILE_EXTENSION }
     */
    public static String getOwnerFileExtension() {
        return OWNER_FILE_EXTENSION;
    }

}
